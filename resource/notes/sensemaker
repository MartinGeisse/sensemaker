
Der Sensemaker liest Code ein, baut daraus eine Datenbank / Code-Modell auf, und beantwortet dann Fragen. 

Plugins erweitern den SM um Fähigkeiten. E/EP-System wie gehabt.

Fragen vs. Sinn: hier geht es um eine Formalität. Auch wenn Formal immer eine Frage gestellt werden muss, damit der SM reagiert, kann diese Frage ja auch sein: "Was ist der Sinn dieses Programms?" Die Details sind demnach den Plugins überlassen.

Zentraler Bestandteil wird eine Wissensdatenbank sein -- im Grunde eine lazy gefüllte key/value map. Entsprechende Provider werden registriert, und dann kann aufgrund eines Keys ein Objekt abgefragt werden. (Der Key ist am besten mit dessen Typ parametrisiert). Ist das Objekt nicht da, wird der entsprechende Provider benutzt, um es zu erzeugen, was wiederum auf die Wissensdatenbank zugreifen kann. Idee: Die ursprünglichen Benutzerfragen können auch darüber abgebildet werden. Im Prinzip kann nach jedem Objekt gefragt werden (bzw. nach jedem Objekt, für das ein Renderer existiert, um es dem Benutzer darzustellen).

Initialer Inhalt der Wissensdatenbank ist der Code, bzw. sogar nur die Angabe, wo dieser zu finden ist. (Dann muss aber davon ausgegangen werden, dass er sich nicht mittendrin ändert).

Auch Requests an die Wissensdatenbank sollten renderable sein: Wenn ein Request nicht beantwortet werden kann, dann sollte dieser ausgegeben werden, damit der Benutzer ihn ggf. beantworten kann.

Evtl. sind nicht nur Anfragen an den Code, sondern auch an eine Datenbank nötig -- vor allem, wenn Code in der DB liegt; aber auch z.B. der Struktur, oder ob bestimmte Situationen vorkommen.

Der SM sollte Annahmen ausgeben. Z.B.: In der DB liegen keine Datensätze mit is_old=0, also treffe ich die Annahme, dass dieser Fall insgesamt nicht vorkommen kann.

------------------------------------

Große Frage ist: Soll der SM von Source Code oder von Class Files ausgehen?
- Wenn Source Files: Dann muss im Prinzip ein Compiler Teil des SM sein
- Wenn Class Files: Dann setzt das voraus, dass der Code überhaupt compilebar ist
- Wenn beides angegeben wird, können die beiden inkonsistent sein
- bei Scriptsprachen kann die Unterscheidung nicht gemacht werden
- Class Files müssten von daher sowieso gehen, weil Bibliotheken so vorliegen
-->
Am schönsten wäre es im Grunde, wenn man dem SM alles geben könnte, was man hat, und er das Maximum herausholt. Wenn beides da ist und inkonsistent, dann soll er das melden.


Was sind denn Fragen an den Code? Die meisten Fragen sind realistisch doch eher: "ich versteh hier nix, was ist denn hier was?"
--> Also die Fragen nach Übersicht. 
--> Diese Frage kann davon ausgehen, dass es keinen unbenutzten Code gibt. (Ansonsten kann wie unten geklärt werden, was unbenutzt ist, und dieser soft (separate Löschtabelle) oder hard gelöscht werden)
Was sind Antworten auf die Frage nach Orientierung?
- Klassen und Methoden werden mit Tags versehen:
	- Klassen
		- Reines Datenobjekt
			- mit equals / hashcode support
			- mit kaputtem equals- oder hashcode-support
		- toString support
		- immutable
	- Methoden
		- Getter
		- Setter
		- Nop-op
		- virtual, final, effectively final (wird nirgendwo überschrieben --> benötigt das Wissen darüber, ob der Code vollständig vorliegt)
		- NOP


Eine weitere Frage ist die nach unbenutztem Code. Die lässt sich beantworten:
- welche Klassen werden nicht statisch benutzt?
- welche Methoden werden nicht statisch benutzt?
- wo finden dynamische Verwendungen statt? Welche davon können durch Programmanalyse "verstatischt" oder zumindest statisch eingegrenzt werden?


Weitere Fragen sind die nach dem Verhalten einzelner Codestücke:
- wie verhält sich f(x=5)? Wie verhält sich f(x<5)? Wie wenn static int foo = 42?
- Unter welchen Bedingungen fliegt gleich eine IllegalArgumentException oder NPE?
- Allgemeiner: Was sind die "Grenzen", wo sich das Verhalten radikal ändert? Im Prinzip werden hier die verschachtelten ifs "flachgedrückt", durch die
	vorhergehenden Befehle "durchgedrückt" und aus deren Bedingungen eine Partition der Funktionsparameter gebaut.

Weitere:
- copy & paste code, auch mit Unterschieden
- toter Code
- abhängigkeiten
- "high-level-Architektur" <-- muss klarer definiert werden
- NICHT: Coding-Richtlinien, insbesondere die oberflächlichen (Formatierung, Naming, cyclo-complexity, ...). Dafür ist Sonarqube da.
- EVTL: Sicherheitslücken. Auch dafür ist eigentlich Sonarqube da. Der Übergang ist aber fließend.
- Implementierung in einer low-level-Sprache (z.B. Java -> Native, auch Assembler und Embedded-Kram)
- Suche nach Race Conditions
- Was-wäre-wenn (näher zu definieren)
- disassembling
- "ganzheitliche Problemsuche" inkl. DB-Daten, Konfiguration etc., was alles nicht Teil des Codes ist; außerdem soll es in der Lage sein, ein vorhandenes
	Projekt zu analysieren, wo auch evtl. ein komplizierter Build stattfindet. Andere Tools kommen nicht damit klar, wenn sie den Build nicht verstehen.
- Refactoring-Vorschläge (idealerweise so automatisiert, dass man diese nur noch per Knopfdruck bestätigen muss. Das braucht aber ggf. gute Integration in IDEs, oder
	es muss selbst Refactoring-Wissen haben. Als eine 80%-Lösung reicht es aber, die Vorschläge zu machen.)
- ideal wäre die Möglichkeit, Code zu analysieren, der nicht compiled
- unklar: Analyse zur Laufzeit. Das kann helfen, kann aber auch total irreführend sein.
- Abhängigkeiten vom Compiler etc. finden (geht aber auch eher in den Sonarqube-Bereich rein)
- Erkennung von Patterns (Class Patterns wie Visitor; Architecture Patterns wie MVC)
- Erkennung von "Projekttypen" (z.B. anhand Frameworks) und Hinweis auf Regeln, die in diesem Projekttyp gelten)
	-> Beispiel-Frage: "was ist in welchem Ordner?"
	-> Antwort: "Dies ist ein CakePHP 2 Projekt. Im Ordner "src" liegt der Quellcode; in "lib" liegt CakePHP selbst; in src/controller sind die Controller-Klassen (Link auf Doku); ..."
- Welche möglichen "Pfade" gibt es (Methodenübergreifend) durch den Code?
- Erkläre folgenden Regex (in Regex-Dialekt XYZ): ...
- Welche Exceptions können hier fliegen (also wirklich, nicht nur Herumgerate)
- Welche "Effekte" kann ein System haben?
	-> wohin können Netzwerkverbindungen aufgemacht werden? Wohin werden HTTP-Requests gesendet?
	-> auf welche lokalen Dateien wird zugegriffen?

Andere Wichtige Features:
- hier entsteht eine Unmenge an Information. Es ist wichtig, diese nicht nur strukturiert darzustellen, sondern auch leicht navigierbar zu machen! Also braucht es einen "Browser" für das Ergebnis, welcher dann auch mit einem Code-Browser einhergeht. Integration in eine IDE wäre cool; webbasierte Darstellung eine Alternative, wo man nicht von ewig vielen Tools abhängig ist, aber dann braucht es natürlich einen Syntax Highlighter (-> CodeMirror!). Beispiele:
	- Klick auf eine Methode: "Zeige mir, wie diese Methode ablaufen kann!"
		- Split nach Parametern / external State (falls größtenteils gleich, diesen Split "nach innen" verschieben)
		- dabei müssten Varianten ausgeschlossen werden, die nach Analyse von anderem Code "nicht vorkommen können"
			-> Invarianten! Z.B.
				"Bei einem fertig erzeugten Objekt der Klasse X ist das feld F niemals null und niemals der Leerstring"
				"Ein Objekt der Klasse K ist niemals Teil einer zyklischen Datenstruktur" (Interna der Standardbibliothek ausgenommen,
					soll heißen Object-Class-Reference wird ignoriert; String gilt als Leaf; ...
				"Ein Objekt der Klasse K bildet immer mit einem Objekt der Klasse A eine zyklische Struktur"
		- jeweils die Abfolge von Befehlen; bei Methodenaufrufen, in welche Methode das reinführen kann (wenn nur 1 möglich, dann Hinweis und warum)
		- dabei Sonderbehandlung von Standardmethoden (z.B. Klasse String), wobei diese auf Wunsch abgeschaltet werden kann
- Plugins sollten automatisch nachgeladen werden, oder zumindest der Vorschlag gemacht werden. Dadurch kann viel spezifisches Wissen verfügbar gemacht werden,
	z.B. über bestimmte Frameworks und Bibliotheken.
	Sicherheitsbedenken werden dabei aufkommen. Dazu wird erst mal viel Review stattfinden müssen, d.h. nur im Sourcecode submittet. Idealerweise kann man
	später aber genau über dieses Tool die Plugins untersuchen, ob sie irgendwas schädliches tun!

Prestige-Beispiele:
- vollständige Dokumentation des Linux-Kernel-Codes
- disassembling eines bekannten Projekts (z.B. Doom oder Quake; Im Java-Umfeld sowas wie Elasticsearch, Eclipse, Tomcat, Minecraft)
	-> hier könnte man z.B. sagen: Wir würden gerne Minecraft disassemblen, aber die rechtliche Siutation ist uns zu heikel. Und dann das Programm so
		vorbereiten, dass Minecraft nirgendwo verlinkt ist, aber wenn man den Link einträgt, out of the box komplett analysiert werden kann.

------------------------------------

v1:
- nur ein classloader
- geht davon aus, dass aller code schon compiled wurde
--> das sind alles nur "v1-Annahmen" !!!

Wie kann das Analysieren überhaupt gehen?
-> Modell der Klassenhierarchie, Methoden, Felder
	Das kann direkt aus den Classfiles aufgebaut werden.
	Erst mal nur auf Java abzielen. Das kann später gut erweitert werden.
-> Kontrollflussanalyse -> entweder ein CFG oder SSA-Pseudo-Assembler wie bei LLVM
	(ist ein CFG auch SSA? möglicherweise wäre das dann die sinnvollste Variante)

------------------------------------

Das Frage-Antwort-Memoize-Prinzip ist schwach! Sinnvoller wäre ein "Erkenntnis-Sammel-Prinzip", weil es darauf setzt, dass eine Erkenntnis zu einer neuen führen kann. Frage-Antwort wäre sinnvoll,
wenn klarer wäre, woher die Antwort kommt.

Also: Jede Erkenntnis kann zu einer neuen führen, und die wieder zu einer neuen. Das klingt nach Event Listener:
- es gibt eine zentrale listener registry
- die root-information (z.B. Ordner, VCS-URL) ist eine Erkenntnis
- jede Erkenntnis wird an alle Listener gesendet
- das passiert aber nur einmal. Die Registry merkt sich jede gesendete Erkenntnis und sendet sie nicht nochmal
- am Ende kann man das Ergebnis ggf. durch eine Frage filtern. Dieser Teil ist noch unklar, aber das wird offensichtlich, wenn bekannt ist, welche Erkenntnisse sich da so anhäufen

Beispiele:
- ClassFile-Ordner -> ClassModels
- ClassModels -> verwendete Frameworks
- ClassModels -> wo wird überall Reflection verwendet
- ClassModels -> Main-Klassen
- wo Reflection -> wo werden beliebige Konstruktoren aufgerufen
- wo Reflection -> wo wird auf Private Fields zugegriffen
- ClassModels, wo wird auf Private Fields zugegriffen --> wird auf beliebige Private Fields zugegriffen?
- ClassModels, Main-Klassen -> Command-Line Parameters

Dieses Prinzip lässt sich auch sehr einfach um beliebiges Wissen aus Plugins erweitern.

---

So ganz ist es das aber noch nicht. Für diverse Erkenntnisse gibt es verschiedene "Versionen" -- erst kommt eine einfache Version, später eine verbesserte (die sich unterscheiden kann),
und evtl. auch wegen einer Art "Race Condition" (Reihenfolge der Listener-Aufrufe; kann auch tatsächlich in Threads passieren) kann eine Erkenntnis "verspätet" kommen und dadurch schlechter
sein, als eine frühere Erkenntnis derselben Art. Dazu muss jede Erkenntnis erst mal genau dokumentieren, wie sie zustande gekommen ist -- dann kann jeder potentielle Consumer zumindest alle
Erkenntnisse mergen. Wenn es bei einer Art von Erkenntnis eine klare Rangfolge gibt (besser vs. schlechter), dann kann diese ja über Methoden abrufbar sein, was es für Consumer einfacher macht.

Trotzdem ist die Frage, was davon im Basis-System abgebildet wird. Gibt es eine Art "Key" für Erkenntnisse, so dass zwei Erkenntnis-Objekt mit demselben "Key" immer zwei Versionen darstellen,
wo nur eine richtig sein kann (aber evtl. keine der präsentierten)? Wenn jedes Erkenntnis-Objekt dokumentiert, wie es zustande gekommen ist, dann ist jedes davon richtig; sie beantworten verschiedene
Fragen. Wenn man das aber auf die Spitze treibt, dann ist es nicht viel hilfreicher als eine Frage-Antwort-Engine. Etwas besseres bekommt man zumindest, wenn die Erkenntnis-Objekt interfaces
implementieren, wodurch ein Consumer alle Erkenntnisse mit bestimmten Interfaces verarbeiten kann. Dann muss immer noch entschieden werden, welches "richtiger" ist.

Ein konkretes Beispiel: Wo wird eine Klasse instanziiert?
- alle Aufrufe des Constructors
- alle Reflection-Verwendungen
- Reflection-Verwendungen gefiltert aufgrund von anderen Erkenntnissen

Ein Ansatz aus dem manuellen Vorgehen wäre es, eine Widerspruchs-Erkennung zu benutzen. Dann müsste nachfolgend der
Widerspruch aufgelöst werden -> "was stimmt denn jetzt?" Danach würde dann eine der Aussagen ungültig, alle
Schlußfolgerungen auch, was evtl. die konkurrierende Aussage *auch* ungültig macht und man hat gar nichts mehr. Dabei
wäre es eigentlich richtig, zu erkennen, dass in der Kette irgendwo die Aussagen *doch* gültig werden, nur mit
anderer Begründung -- was man aber noch schwerer erkennen kann. Das führt so zu nichts.

Besser ist da schon der Ansatz mit Interfaces, so dass verschiedene Grundlagen auf dieselbe Art zu einer Schlußfolgerung
führen können. Z.B. kann die Liste der direkten Konstrukturaufrufe genauso wie die Liste von Reflection-Konstruktoraufrufen
zu einer Liste von instanziierten konkreten Klassen führen. Beide "wissen", dass sie nicht exklusiv sind, aber beide
können auf dieselbe Art verwendet werden --> Interface! Zusammen mit Annahmen (keine Konstruktoraufrufe aus
Native Code heraus -> das sollte ein Default, aber explizit und sichtbar sein) wird daraus eine Abschließende Liste von
instanziierten Klassen.

Wo sind die Vorteile zu Anfrage-Antwort? Die Interfaces sind ein Vorteil, aber das alleine ist noch zu schwach. Wichtig
wäre es, dieselbe Erkenntnis auf verschiedenen Wegen finden zu können. Das Hauptproblem scheint dabei zu sein, dass man
für eine brauchbare Erkenntnis eine "beidseitige" Aussage braucht: Also bei den Konstruktoraufrufen eine Liste ohne
falsche Elemente und ohne fehlende Elemente. Die lässt sich schlecht einseitig durch Plugins erweitern.

Weiter gedacht ist das Problem, dass man eine definitive Aussage will, aber auf der Basis von "mitwirkenden" Plugins.
Zu allererst ist mal zu klären, ob diese Wunschvorstellung überhaupt realistisch / sinnvoll ist. Ich will es nicht
von vornherein ausschließen: Die Beweisführung muss nach allen Seiten hin hieb- und stichfest sein, aber der Weg, auf
dem die Beweisführung gefunden wird, kann beliebig schwammig sein.
-->
Wenn man das weiterdenkt, wird langsam klar, wie die Wunschvorstellung konkret aussieht: so etwas ähnliches wie Verifun,
aber für prozedurale Sprachen und mit Heuristiken, welche die zu beweisenden Aussagen automatisch generieren.
-->
Nach nochmaligem drüber Nachdenken kann ich das nur bestätigen. Schwammige Aussagen über den Code kann man in mehreren
Stufen auch selbst treffen -- die sind aber selten viel Wert, weil man bei "interessantem" Code fast immer merkt, dass es
doch ganz anders ist. Wasserdichte Aussagen sind das wirklich wertvolle:
- als Ausgangspunkt sollte für die meisten Aussagen klar sein, welcher Code (maximal) verwendet wird. Eine solche Obergrenze lässt sich aber fast immer
	finden, notfalls mit Zwischenschritten. Meistens ist es eine Kombination aus Basiscode, Plugins von irgendwoher und Code aus der Datenbank.
	Erst wenn Downloads von beliebigen Quellen erlaubt sind, wird es haarig. Das passiert aber nicht sehr oft.
- Damit sind dann Obergrenzen bekannt, welche Klassen es gibt -- und damit auch mögliche Implementierungen für jede Methode.
	--> Idee: Hier kann im schlimmsten Fall herauskommen, dass doch Code von woandersher kommt (z.B.: es war in der ersten
		Runde nicht bekannt, dass Code in der DB liegt). In diesem Fall wäre es die einfachste Lösung, dass die Engine sich
		gar nicht wieder "erholen" kann, sondern mit dem Widerspruch diese Runde abgebrochen wird. Dann muss der Benutzer
		die Annahmen anpassen (z.B. Datenbankzugang herstellen) und das Tool neu starten. 
	--> Im schlimmsten Fall kann ein übergeordnetes Tool das tun.
- Auf dieser Grundlage kann dann evtl. Stück für Stück erkannt werden, welche von diesen Klassen wirklich verwendet werden.
	Beispiel:
	- bekannte Frameworks, die Reflection einsetzen, und wie diese sich verhalten (z.B. Wissen darüber, wie Spring-XML-Dateien funktionieren)
	- Klassen, deren Konstrukturen nicht zu der Art und Weise passen, wie Konstrukturen per Reflection aufgerufen werden (Anzahl und Typ der Parameter)
	- Reflection-verwendender Code, der niemals ausgeführt wird

